<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX9E3049D7A5484A7BB9A6142B720A1414">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">MCPPlugin</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX23BB577C785944B990DA9EC000175D34">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Script</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{6B995C47-F092-49E6-9570-006CEAF32B0C}</string>
				<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local StudioService = game:GetService("StudioService")
local Selection = game:GetService("Selection")
local RunService = game:GetService("RunService")
local ChangeHistoryService = game:GetService("ChangeHistoryService")

local toolbar = plugin:CreateToolbar("MCP Integration")
local button =
	toolbar:CreateButton("MCP Server", "Connect to MCP Server for AI Integration", "rbxassetid://10734944444")

local pluginState = {
	serverUrl = "http://localhost:3002",
	mcpServerUrl = "http://localhost:3001",
	isActive = false,
	pollInterval = 0.5,
	lastPoll = 0,
	consecutiveFailures = 0,
	maxFailuresBeforeError = 50,
	lastSuccessfulConnection = 0,
	currentRetryDelay = 0.5,
	maxRetryDelay = 5,
	retryBackoffMultiplier = 1.2,
}

local screenGui = plugin:CreateDockWidgetPluginGui(
	"MCPServerInterface",
	DockWidgetPluginGuiInfo.new(Enum.InitialDockState.Float, false, false, 300, 200, 280, 180)
)
screenGui.Title = "MCP Server Interface"

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(1, 0, 1, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(46, 46, 46)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = screenGui

local headerFrame = Instance.new("Frame")
headerFrame.Size = UDim2.new(1, 0, 0, 40)
headerFrame.Position = UDim2.new(0, 0, 0, 0)
headerFrame.BackgroundColor3 = Color3.fromRGB(37, 37, 37)
headerFrame.BorderSizePixel = 0
headerFrame.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -10, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "MCP Server"
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextScaled = false
titleLabel.TextSize = 16
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = headerFrame

local statusIndicator = Instance.new("Frame")
statusIndicator.Size = UDim2.new(0, 12, 0, 12)
statusIndicator.Position = UDim2.new(1, -20, 0.5, -6)
statusIndicator.BackgroundColor3 = Color3.fromRGB(255, 85, 85)
statusIndicator.BorderSizePixel = 0
statusIndicator.Parent = headerFrame

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = statusIndicator

local contentFrame = Instance.new("Frame")
contentFrame.Size = UDim2.new(1, -20, 1, -60)
contentFrame.Position = UDim2.new(0, 10, 0, 50)
contentFrame.BackgroundTransparency = 1
contentFrame.Parent = mainFrame

local urlLabel = Instance.new("TextLabel")
urlLabel.Size = UDim2.new(1, 0, 0, 20)
urlLabel.Position = UDim2.new(0, 0, 0, 0)
urlLabel.BackgroundTransparency = 1
urlLabel.Text = "Server URL:"
urlLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
urlLabel.TextScaled = false
urlLabel.TextSize = 14
urlLabel.Font = Enum.Font.SourceSans
urlLabel.TextXAlignment = Enum.TextXAlignment.Left
urlLabel.Parent = contentFrame

local urlInput = Instance.new("TextBox")
urlInput.Size = UDim2.new(1, 0, 0, 25)
urlInput.Position = UDim2.new(0, 0, 0, 25)
urlInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
urlInput.BorderSizePixel = 0
urlInput.Text = "http://localhost:3002"
urlInput.TextColor3 = Color3.fromRGB(255, 255, 255)
urlInput.TextScaled = false
urlInput.TextSize = 12
urlInput.Font = Enum.Font.SourceSans
urlInput.ClearTextOnFocus = false
urlInput.Parent = contentFrame

local inputCorner = Instance.new("UICorner")
inputCorner.CornerRadius = UDim.new(0, 4)
inputCorner.Parent = urlInput

local inputPadding = Instance.new("UIPadding")
inputPadding.PaddingLeft = UDim.new(0, 8)
inputPadding.PaddingRight = UDim.new(0, 8)
inputPadding.Parent = urlInput

local statusLabel = Instance.new("TextLabel")
statusLabel.Size = UDim2.new(1, 0, 0, 20)
statusLabel.Position = UDim2.new(0, 0, 0, 60)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = "Status: Disconnected"
statusLabel.TextColor3 = Color3.fromRGB(255, 85, 85)
statusLabel.TextScaled = false
statusLabel.TextSize = 14
statusLabel.Font = Enum.Font.SourceSans
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Parent = contentFrame

local connectButton = Instance.new("TextButton")
connectButton.Size = UDim2.new(1, 0, 0, 35)
connectButton.Position = UDim2.new(0, 0, 0, 90)
connectButton.BackgroundColor3 = Color3.fromRGB(0, 162, 255)
connectButton.BorderSizePixel = 0
connectButton.Text = "Connect"
connectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
connectButton.TextScaled = false
connectButton.TextSize = 16
connectButton.Font = Enum.Font.SourceSansBold
connectButton.Parent = contentFrame

local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(0, 6)
buttonCorner.Parent = connectButton

local buttonHover = false
connectButton.MouseEnter:Connect(function()
	buttonHover = true
	if not pluginState.isActive then
		connectButton.BackgroundColor3 = Color3.fromRGB(30, 180, 255)
	else
		connectButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
	end
end)

connectButton.MouseLeave:Connect(function()
	buttonHover = false
	if not pluginState.isActive then
		connectButton.BackgroundColor3 = Color3.fromRGB(0, 162, 255)
	else
		connectButton.BackgroundColor3 = Color3.fromRGB(255, 85, 85)
	end
end)

local function safeCall(func, ...)
	local success, result = pcall(func, ...)
	if success then
		return result
	else
		warn("MCP Plugin Error: " .. tostring(result))
		return nil
	end
end

local function getInstancePath(instance)
	if not instance or instance == game then
		return "game"
	end

	local path = {}
	local current = instance

	while current and current ~= game do
		table.insert(path, 1, current.Name)
		current = current.Parent
	end

	return "game." .. table.concat(path, ".")
end

local processRequest
local sendResponse
local handlers = {}

local function pollForRequests()
	if not pluginState.isActive then
		return
	end

	local success, result = pcall(function()
		return HttpService:RequestAsync({
			Url = pluginState.serverUrl .. "/poll",
			Method = "GET",
			Headers = {
				["Content-Type"] = "application/json",
			},
		})
	end)

	if success and result.Success then
		pluginState.consecutiveFailures = 0
		pluginState.currentRetryDelay = 0.5
		pluginState.lastSuccessfulConnection = tick()

		if statusLabel.Text ~= "Status: Connected" then
			statusLabel.Text = "Status: Connected"
			statusLabel.TextColor3 = Color3.fromRGB(85, 255, 85)
			statusIndicator.BackgroundColor3 = Color3.fromRGB(85, 255, 85)
		end

		local data = HttpService:JSONDecode(result.Body)
		if data.request then
			local response = processRequest(data.request)
			sendResponse(data.requestId, response)
		end
	elseif pluginState.isActive then
		pluginState.consecutiveFailures = pluginState.consecutiveFailures + 1

		if pluginState.consecutiveFailures > 1 then
			pluginState.currentRetryDelay =
				math.min(pluginState.currentRetryDelay * pluginState.retryBackoffMultiplier, pluginState.maxRetryDelay)
		end

		if pluginState.consecutiveFailures >= pluginState.maxFailuresBeforeError then
			statusLabel.Text = "Status: Server Unavailable"
			statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
			statusIndicator.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
		elseif pluginState.consecutiveFailures > 5 then
			local waitTime = math.ceil(pluginState.currentRetryDelay)
			statusLabel.Text = "Status: Waiting for server... (" .. waitTime .. "s)"
			statusLabel.TextColor3 = Color3.fromRGB(255, 200, 85)
			statusIndicator.BackgroundColor3 = Color3.fromRGB(255, 200, 85)
		elseif pluginState.consecutiveFailures > 1 then
			statusLabel.Text = "Status: Connecting... (" .. pluginState.consecutiveFailures .. ")"
			statusLabel.TextColor3 = Color3.fromRGB(255, 255, 85)
			statusIndicator.BackgroundColor3 = Color3.fromRGB(255, 255, 85)
		end
	end
end

sendResponse = function(requestId, responseData)
	pcall(function()
		HttpService:RequestAsync({
			Url = pluginState.serverUrl .. "/response",
			Method = "POST",
			Headers = {
				["Content-Type"] = "application/json",
			},
			Body = HttpService:JSONEncode({
				requestId = requestId,
				response = responseData,
			}),
		})
	end)
end

processRequest = function(request)
	local endpoint = request.endpoint
	local data = request.data or {}

	if endpoint == "/api/file-tree" then
		return handlers.getFileTree(data)
	elseif endpoint == "/api/file-content" then
		return handlers.getFileContent(data)
	elseif endpoint == "/api/search-files" then
		return handlers.searchFiles(data)
	elseif endpoint == "/api/file-properties" then
		return handlers.getFileProperties(data)
	elseif endpoint == "/api/place-info" then
		return handlers.getPlaceInfo(data)
	elseif endpoint == "/api/services" then
		return handlers.getServices(data)
	elseif endpoint == "/api/selection" then
		return handlers.getSelection(data)
	elseif endpoint == "/api/search-objects" then
		return handlers.searchObjects(data)
	elseif endpoint == "/api/instance-properties" then
		return handlers.getInstanceProperties(data)
	elseif endpoint == "/api/instance-children" then
		return handlers.getInstanceChildren(data)
	elseif endpoint == "/api/search-by-property" then
		return handlers.searchByProperty(data)
	elseif endpoint == "/api/class-info" then
		return handlers.getClassInfo(data)
	elseif endpoint == "/api/project-structure" then
		return handlers.getProjectStructure(data)
	elseif endpoint == "/api/dependencies" then
		return handlers.getDependencies(data)
	elseif endpoint == "/api/validate-references" then
		return handlers.validateReferences(data)
	else
		return { error = "Unknown endpoint: " .. tostring(endpoint) }
	end
end

local function getInstanceByPath(path)
	if path == "game" or path == "" then
		return game
	end

	path = path:gsub("^game%.", "")

	local parts = {}
	for part in path:gmatch("[^%.]+") do
		table.insert(parts, part)
	end

	local current = game
	for _, part in ipairs(parts) do
		current = current:FindFirstChild(part)
		if not current then
			return nil
		end
	end

	return current
end

handlers.getFileTree = function(requestData)
	local path = requestData.path or ""
	local startInstance = getInstanceByPath(path)

	if not startInstance then
		return { error = "Path not found: " .. path }
	end

	local function buildTree(instance, depth)
		if depth > 10 then
			return { name = instance.Name, className = instance.ClassName, children = {} }
		end

		local node = {
			name = instance.Name,
			className = instance.ClassName,
			path = getInstancePath(instance),
			children = {},
		}

		if instance:IsA("BaseScript") then
			node.hasSource = true
			node.scriptType = instance.ClassName
		end

		for _, child in ipairs(instance:GetChildren()) do
			table.insert(node.children, buildTree(child, depth + 1))
		end

		return node
	end

	return {
		tree = buildTree(startInstance, 0),
		timestamp = tick(),
	}
end

handlers.getFileContent = function(requestData)
	local path = requestData.path
	if not path then
		return { error = "Path is required" }
	end

	local instance = getInstanceByPath(path)
	if not instance then
		return { error = "Instance not found: " .. path }
	end

	if not instance:IsA("BaseScript") then
		return { error = "Instance is not a script: " .. path }
	end

	return {
		path = path,
		source = instance.Source,
		className = instance.ClassName,
		name = instance.Name,
	}
end

handlers.searchFiles = function(requestData)
	local query = requestData.query
	local searchType = requestData.searchType or "name"

	if not query then
		return { error = "Query is required" }
	end

	local results = {}

	local function searchRecursive(instance)
		local match = false

		if searchType == "name" then
			match = instance.Name:lower():find(query:lower()) ~= nil
		elseif searchType == "type" then
			match = instance.ClassName:lower():find(query:lower()) ~= nil
		elseif searchType == "content" and instance:IsA("BaseScript") then
			match = instance.Source:lower():find(query:lower()) ~= nil
		end

		if match then
			table.insert(results, {
				name = instance.Name,
				className = instance.ClassName,
				path = getInstancePath(instance),
				hasSource = instance:IsA("BaseScript"),
			})
		end

		for _, child in ipairs(instance:GetChildren()) do
			searchRecursive(child)
		end
	end

	searchRecursive(game)

	return {
		results = results,
		query = query,
		searchType = searchType,
		count = #results,
	}
end

handlers.getFileProperties = function(requestData)
	local path = requestData.path
	if not path then
		return { error = "Path is required" }
	end

	local instance = getInstanceByPath(path)
	if not instance then
		return { error = "Instance not found: " .. path }
	end

	local properties = {}
	local success, result = pcall(function()
		properties.Name = instance.Name
		properties.ClassName = instance.ClassName
		properties.Parent = instance.Parent and getInstancePath(instance.Parent) or "nil"

		properties.ChildCount = #instance:GetChildren()

		if instance:IsA("BaseScript") then
			properties.Source = instance.Source
			properties.Enabled = instance.Enabled
		end

		return properties
	end)

	if success then
		return {
			path = path,
			properties = properties,
		}
	else
		return { error = "Failed to get properties: " .. tostring(result) }
	end
end

handlers.getPlaceInfo = function(requestData)
	return {
		placeName = game.Name,
		placeId = game.PlaceId,
		gameId = game.GameId,
		jobId = game.JobId,
		workspace = {
			name = workspace.Name,
			className = workspace.ClassName,
		},
	}
end

handlers.getServices = function(requestData)
	local serviceName = requestData.serviceName

	if serviceName then
		local service = safeCall(game.GetService, game, serviceName)
		if service then
			return {
				service = {
					name = service.Name,
					className = service.ClassName,
					path = getInstancePath(service),
					childCount = #service:GetChildren(),
				},
			}
		else
			return { error = "Service not found: " .. serviceName }
		end
	else
		local services = {}
		local commonServices = {
			"Workspace",
			"Players",
			"StarterGui",
			"StarterPack",
			"StarterPlayer",
			"ReplicatedStorage",
			"ServerStorage",
			"ServerScriptService",
			"HttpService",
			"TeleportService",
			"DataStoreService",
		}

		for _, serviceName in ipairs(commonServices) do
			local service = safeCall(game.GetService, game, serviceName)
			if service then
				table.insert(services, {
					name = service.Name,
					className = service.ClassName,
					path = getInstancePath(service),
					childCount = #service:GetChildren(),
				})
			end
		end

		return { services = services }
	end
end

handlers.getSelection = function(requestData)
	local selected = Selection:Get()
	local selection = {}

	for _, instance in ipairs(selected) do
		table.insert(selection, {
			name = instance.Name,
			className = instance.ClassName,
			path = getInstancePath(instance),
		})
	end

	return {
		selection = selection,
		count = #selection,
	}
end

handlers.searchObjects = function(requestData)
	local query = requestData.query
	local searchType = requestData.searchType or "name"
	local propertyName = requestData.propertyName

	if not query then
		return { error = "Query is required" }
	end

	local results = {}

	local function searchRecursive(instance)
		local match = false

		if searchType == "name" then
			match = instance.Name:lower():find(query:lower()) ~= nil
		elseif searchType == "class" then
			match = instance.ClassName:lower():find(query:lower()) ~= nil
		elseif searchType == "property" and propertyName then
			local success, value = pcall(function()
				return tostring(instance[propertyName])
			end)
			if success then
				match = value:lower():find(query:lower()) ~= nil
			end
		end

		if match then
			table.insert(results, {
				name = instance.Name,
				className = instance.ClassName,
				path = getInstancePath(instance),
			})
		end

		for _, child in ipairs(instance:GetChildren()) do
			searchRecursive(child)
		end
	end

	searchRecursive(game)

	return {
		results = results,
		query = query,
		searchType = searchType,
		count = #results,
	}
end

handlers.getInstanceProperties = function(requestData)
	local instancePath = requestData.instancePath
	if not instancePath then
		return { error = "Instance path is required" }
	end

	local instance = getInstanceByPath(instancePath)
	if not instance then
		return { error = "Instance not found: " .. instancePath }
	end

	local properties = {}
	local success, result = pcall(function()
		local classInfo = {}

		local basicProps = { "Name", "ClassName", "Parent" }
		for _, prop in ipairs(basicProps) do
			local propSuccess, propValue = pcall(function()
				local val = instance[prop]
				if prop == "Parent" and val then
					return getInstancePath(val)
				elseif val == nil then
					return "nil"
				else
					return tostring(val)
				end
			end)
			if propSuccess then
				properties[prop] = propValue
			end
		end

		local commonProps = {
			"Size",
			"Position",
			"Rotation",
			"CFrame",
			"Anchored",
			"CanCollide",
			"Transparency",
			"BrickColor",
			"Material",
			"Color",
			"Text",
			"TextColor3",
			"BackgroundColor3",
			"Image",
			"ImageColor3",
			"Visible",
			"Active",
			"ZIndex",
			"BorderSizePixel",
			"BackgroundTransparency",
			"ImageTransparency",
			"TextTransparency",
			"Value",
			"Enabled",
			"Brightness",
			"Range",
			"Shadows",
			"Face",
			"SurfaceType",
		}

		for _, prop in ipairs(commonProps) do
			local propSuccess, propValue = pcall(function()
				return tostring(instance[prop])
			end)
			if propSuccess then
				properties[prop] = propValue
			end
		end

		if instance:IsA("BaseScript") then
			properties.Source = instance.Source
			properties.Enabled = tostring(instance.Enabled)
		end

		if instance:IsA("BasePart") then
			properties.Shape = tostring(instance.Shape)
			properties.TopSurface = tostring(instance.TopSurface)
			properties.BottomSurface = tostring(instance.BottomSurface)
		end

		properties.ChildCount = tostring(#instance:GetChildren())

		return properties
	end)

	if success then
		return {
			instancePath = instancePath,
			className = instance.ClassName,
			properties = properties,
		}
	else
		return { error = "Failed to get properties: " .. tostring(result) }
	end
end

handlers.getInstanceChildren = function(requestData)
	local instancePath = requestData.instancePath
	if not instancePath then
		return { error = "Instance path is required" }
	end

	local instance = getInstanceByPath(instancePath)
	if not instance then
		return { error = "Instance not found: " .. instancePath }
	end

	local children = {}
	for _, child in ipairs(instance:GetChildren()) do
		table.insert(children, {
			name = child.Name,
			className = child.ClassName,
			path = getInstancePath(child),
			hasChildren = #child:GetChildren() > 0,
			hasSource = child:IsA("BaseScript"),
		})
	end

	return {
		instancePath = instancePath,
		children = children,
		count = #children,
	}
end

handlers.searchByProperty = function(requestData)
	local propertyName = requestData.propertyName
	local propertyValue = requestData.propertyValue

	if not propertyName or not propertyValue then
		return { error = "Property name and value are required" }
	end

	local results = {}

	local function searchRecursive(instance)
		local success, value = pcall(function()
			return tostring(instance[propertyName])
		end)

		if success and value:lower():find(propertyValue:lower()) then
			table.insert(results, {
				name = instance.Name,
				className = instance.ClassName,
				path = getInstancePath(instance),
				propertyValue = value,
			})
		end

		for _, child in ipairs(instance:GetChildren()) do
			searchRecursive(child)
		end
	end

	searchRecursive(game)

	return {
		propertyName = propertyName,
		propertyValue = propertyValue,
		results = results,
		count = #results,
	}
end

handlers.getClassInfo = function(requestData)
	local className = requestData.className
	if not className then
		return { error = "Class name is required" }
	end

	local success, tempInstance = pcall(function()
		return Instance.new(className)
	end)

	if not success then
		return { error = "Invalid class name: " .. className }
	end

	local classInfo = {
		className = className,
		properties = {},
		methods = {},
		events = {},
	}

	local commonProps = {
		"Name",
		"ClassName",
		"Parent",
		"Size",
		"Position",
		"Rotation",
		"CFrame",
		"Anchored",
		"CanCollide",
		"Transparency",
		"BrickColor",
		"Material",
		"Color",
		"Text",
		"TextColor3",
		"BackgroundColor3",
		"Image",
		"ImageColor3",
		"Visible",
		"Active",
		"ZIndex",
		"BorderSizePixel",
		"BackgroundTransparency",
		"ImageTransparency",
		"TextTransparency",
		"Value",
		"Enabled",
		"Brightness",
		"Range",
		"Shadows",
	}

	for _, prop in ipairs(commonProps) do
		local propSuccess, _ = pcall(function()
			return tempInstance[prop]
		end)
		if propSuccess then
			table.insert(classInfo.properties, prop)
		end
	end

	local commonMethods = {
		"Destroy",
		"Clone",
		"FindFirstChild",
		"FindFirstChildOfClass",
		"GetChildren",
		"IsA",
		"IsAncestorOf",
		"IsDescendantOf",
		"WaitForChild",
	}

	for _, method in ipairs(commonMethods) do
		local methodSuccess, _ = pcall(function()
			return tempInstance[method]
		end)
		if methodSuccess then
			table.insert(classInfo.methods, method)
		end
	end

	tempInstance:Destroy()

	return classInfo
end

handlers.getProjectStructure = function(requestData)
	local startPath = requestData.path or ""
	local maxDepth = requestData.maxDepth or 3
	local showScriptsOnly = requestData.scriptsOnly or false

	local startInstance
	if startPath == "" or startPath == "game" then
		local services = {}
		local mainServices = {
			"Workspace",
			"ServerScriptService",
			"ServerStorage",
			"ReplicatedStorage",
			"StarterGui",
			"StarterPack",
			"StarterPlayer",
			"Players",
		}

		for _, serviceName in ipairs(mainServices) do
			local service = safeCall(game.GetService, game, serviceName)
			if service then
				local serviceInfo = {
					name = service.Name,
					className = service.ClassName,
					path = getInstancePath(service),
					childCount = #service:GetChildren(),
					hasChildren = #service:GetChildren() > 0,
				}
				table.insert(services, serviceInfo)
			end
		end

		return {
			type = "service_overview",
			services = services,
			timestamp = tick(),
			note = "Use path parameter to explore specific locations (e.g., 'game.ServerScriptService')",
		}
	else
		startInstance = getInstanceByPath(startPath)
		if not startInstance then
			return { error = "Path not found: " .. startPath }
		end
	end

	local function getStructure(instance, depth, currentPath)
		if depth > maxDepth then
			return {
				name = instance.Name,
				className = instance.ClassName,
				path = getInstancePath(instance),
				childCount = #instance:GetChildren(),
				hasMore = true,
				note = "Max depth reached - use this path to explore further",
			}
		end

		local node = {
			name = instance.Name,
			className = instance.ClassName,
			path = getInstancePath(instance),
			children = {},
		}

		if instance:IsA("BaseScript") then
			node.hasSource = true
			node.scriptType = instance.ClassName
			node.enabled = instance.Enabled
		end

		if instance:IsA("GuiObject") then
			node.visible = instance.Visible
			if instance:IsA("Frame") or instance:IsA("ScreenGui") then
				node.guiType = "container"
			elseif instance:IsA("TextLabel") or instance:IsA("TextButton") then
				node.guiType = "text"
				if instance.Text and instance.Text ~= "" then
					node.text = instance.Text
				end
			elseif instance:IsA("ImageLabel") or instance:IsA("ImageButton") then
				node.guiType = "image"
			end
		end

		local children = instance:GetChildren()
		if showScriptsOnly then
			local scriptChildren = {}
			for _, child in ipairs(children) do
				if child:IsA("BaseScript") or child:IsA("Folder") or child:IsA("ModuleScript") then
					table.insert(scriptChildren, child)
				end
			end
			children = scriptChildren
		end

		local childCount = #children
		if childCount > 20 and depth < maxDepth then
			local classGroups = {}
			for _, child in ipairs(children) do
				local className = child.ClassName
				if not classGroups[className] then
					classGroups[className] = {}
				end
				table.insert(classGroups[className], child)
			end

			node.childSummary = {}
			for className, classChildren in pairs(classGroups) do
				table.insert(node.childSummary, {
					className = className,
					count = #classChildren,
					examples = {
						classChildren[1] and classChildren[1].Name,
						classChildren[2] and classChildren[2].Name,
					},
				})
			end

			for className, classChildren in pairs(classGroups) do
				for i = 1, math.min(3, #classChildren) do
					table.insert(node.children, getStructure(classChildren[i], depth + 1, currentPath))
				end
				if #classChildren > 3 then
					table.insert(node.children, {
						name = "... " .. (#classChildren - 3) .. " more " .. className .. " objects",
						className = "MoreIndicator",
						path = getInstancePath(instance) .. " [" .. className .. " children]",
						note = "Use specific path to explore these objects",
					})
				end
			end
		else
			for _, child in ipairs(children) do
				table.insert(node.children, getStructure(child, depth + 1, currentPath))
			end
		end

		return node
	end

	local result = getStructure(startInstance, 0, startPath)
	result.requestedPath = startPath
	result.maxDepth = maxDepth
	result.scriptsOnly = showScriptsOnly
	result.timestamp = tick()

	return result
end

handlers.getDependencies = function(requestData)
	local modulePath = requestData.modulePath
	local dependencies = {
		requires = {},
		requiredBy = {},
		timestamp = tick(),
	}

	local function findRequires(instance)
		if instance:IsA("BaseScript") and instance.Source then
			local requires = {}
			for match in instance.Source:gmatch("require%s*%(([^)]+)%)") do
				local cleanMatch = match:gsub("%s+", "")
				table.insert(requires, cleanMatch)
			end
			return requires
		end
		return {}
	end

	local function searchAllScripts()
		local allRequires = {}

		local function searchRecursive(instance)
			if instance:IsA("BaseScript") then
				local requires = findRequires(instance)
				if #requires > 0 then
					allRequires[getInstancePath(instance)] = requires
				end
			end

			for _, child in ipairs(instance:GetChildren()) do
				searchRecursive(child)
			end
		end

		searchRecursive(game)
		return allRequires
	end

	if modulePath then
		local instance = getInstanceByPath(modulePath)
		if instance and instance:IsA("BaseScript") then
			dependencies.requires = findRequires(instance)
		end
	end

	local allRequires = searchAllScripts()
	dependencies.allRequires = allRequires

	return dependencies
end

handlers.validateReferences = function(requestData)
	local issues = {}
	local stats = {
		totalScripts = 0,
		scriptsWithIssues = 0,
		totalIssues = 0,
	}

	local function validateScript(instance)
		if not instance:IsA("BaseScript") or not instance.Source then
			return
		end

		stats.totalScripts = stats.totalScripts + 1
		local scriptIssues = {}

		for match in instance.Source:gmatch("require%s*%(([^)]+)%)") do
			local requirePath = match:gsub("%s+", ""):gsub('"', ""):gsub("'", "")

			local success, result = pcall(function()
				if requirePath:match("^game%.") then
					return getInstanceByPath(requirePath)
				end
				return nil
			end)

			if not success or not result then
				table.insert(scriptIssues, {
					type = "broken_require",
					line = "unknown",
					message = "Cannot resolve require: " .. requirePath,
					requirePath = requirePath,
				})
			end
		end

		local commonServices = {
			"Workspace",
			"Players",
			"ReplicatedStorage",
			"ServerStorage",
			"ServerScriptService",
			"StarterGui",
			"HttpService",
			"TeleportService",
		}

		for _, serviceName in ipairs(commonServices) do
			if
				instance.Source:find(serviceName .. "Service")
				and serviceName ~= "HttpService"
				and serviceName ~= "TeleportService"
			then
				table.insert(scriptIssues, {
					type = "potential_typo",
					line = "unknown",
					message = "Potential typo: " .. serviceName .. "Service should be " .. serviceName,
					suggestion = serviceName,
				})
			end
		end

		if #scriptIssues > 0 then
			stats.scriptsWithIssues = stats.scriptsWithIssues + 1
			stats.totalIssues = stats.totalIssues + #scriptIssues
			issues[getInstancePath(instance)] = scriptIssues
		end
	end

	local function validateRecursive(instance)
		validateScript(instance)
		for _, child in ipairs(instance:GetChildren()) do
			validateRecursive(child)
		end
	end

	validateRecursive(game)

	return {
		issues = issues,
		stats = stats,
		timestamp = tick(),
	}
end

local function updateUIState()
	if pluginState.isActive then
		statusLabel.Text = "Status: Connecting..."
		statusLabel.TextColor3 = Color3.fromRGB(255, 200, 85)
		statusIndicator.BackgroundColor3 = Color3.fromRGB(255, 200, 85)
		connectButton.Text = "Disconnect"
		if not buttonHover then
			connectButton.BackgroundColor3 = Color3.fromRGB(255, 85, 85)
		end
		urlInput.TextEditable = false
		urlInput.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	else
		statusLabel.Text = "Status: Disconnected"
		statusLabel.TextColor3 = Color3.fromRGB(255, 85, 85)
		statusIndicator.BackgroundColor3 = Color3.fromRGB(255, 85, 85)
		connectButton.Text = "Connect"
		if not buttonHover then
			connectButton.BackgroundColor3 = Color3.fromRGB(0, 162, 255)
		end
		urlInput.TextEditable = true
		urlInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	end
end

local function activatePlugin()
	pluginState.serverUrl = urlInput.Text

	pluginState.isActive = true
	pluginState.consecutiveFailures = 0
	pluginState.currentRetryDelay = 0.5
	screenGui.Enabled = true
	updateUIState()

	pcall(function()
		HttpService:RequestAsync({
			Url = pluginState.serverUrl .. "/ready",
			Method = "POST",
			Headers = {
				["Content-Type"] = "application/json",
			},
			Body = HttpService:JSONEncode({
				pluginReady = true,
				timestamp = tick(),
			}),
		})
	end)

	if not pluginState.connection then
		pluginState.connection = RunService.Heartbeat:Connect(function()
			local now = tick()
			local currentInterval = pluginState.consecutiveFailures > 5 and pluginState.currentRetryDelay
				or pluginState.pollInterval
			if now - pluginState.lastPoll > currentInterval then
				pluginState.lastPoll = now
				pollForRequests()
			end
		end)
	end
end

local function deactivatePlugin()
	pluginState.isActive = false
	updateUIState()

	if pluginState.connection then
		pluginState.connection:Disconnect()
		pluginState.connection = nil
	end
end

connectButton.Activated:Connect(function()
	if pluginState.isActive then
		deactivatePlugin()
	else
		activatePlugin()
	end
end)

button.Click:Connect(function()
	screenGui.Enabled = not screenGui.Enabled
end)

plugin.Unloading:Connect(function()
	deactivatePlugin()
end)

updateUIState()
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>